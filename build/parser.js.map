{"version":3,"sources":["../src/parser.js"],"names":["OPENNING","CLOSING","SELFCLOSING","TEXT","Parser","constructor","src","scanner","ast","toVTree","resetSource","_parse","stack","token","getToken","_depth","top","attrs","tagType","keys","_type","push","length","Error","tagName","pop","_reduce","childIndex","parentIndex","child","parent","children","shift"],"mappings":"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","file":"parser.js","sourcesContent":["import { type, Scanner } from './lexer';\n\nconst { OPENNING, CLOSING, SELFCLOSING, TEXT } = type;\n\nexport class Parser {\n  constructor(src) {\n    this.src = src || ''; // current source.\n    this.scanner = new Scanner(this.src);\n    this.ast = {};        // cached.\n  }\n\n  toVTree(src) {\n    // If it is already cached, return it.\n    if (src && this.ast[src]) {\n      return this.ast[src];\n    // If a new source is given, make a new scanner instance.\n    } else if (src) {\n      this.src = src;\n      this.scanner.resetSource(src);\n    }\n\n    return this._parse();\n  }\n\n  // This method only depends on `this.scanner`.\n  _parse() {\n    let stack   = [], // stack for holding \n        ast     = [], // will be reduced to an ast.\n        src     = this.src,\n        scanner = this.scanner,\n        token   = scanner.getToken(),\n        _depth   = 0,    // depth level, start from the outermost.\n        top     = void 0, // element on top of `stack`.\n        attrs   = void 0, // current tag's attrs.\n        tagType = \"static\",\n        keys    = null;\n      \n    while(token) {\n      token._depth = _depth;\n\n      switch(token._type) {\n      case OPENNING:\n        stack.push(token);\n        _depth++;\n        break;\n      case TEXT:\n        ast.push(token);\n        break;\n      case CLOSING:\n        if (stack.length === 0)\n          throw new Error(`Unmatched tag: ${token.tagName}`);\n\n        top = stack.pop();\n        if (top.tagName !== token.tagName)\n          throw new Error(`Unmatched tag: ${token.tagName}`);\n\n        ast.push(top);\n        _depth--;\n        break;\n      default:  // SELFCLOSING\n        attrs = token.attrs || void 0;\n        //keys = Object.keys(attrs);\n\n        ast.push(token);\n      }\n      token = scanner.getToken();\n    }\n\n    // cache it.\n    this.ast[src] = this._reduce(ast);\n    return this.ast[src];\n  }\n\n  _reduce(ast) {\n    let childIndex, parentIndex,\n        child, parent;\n\n    while (ast.length > 1) {\n      parentIndex = 0;\n\n      // Find the most nearest shallower element.\n      while(parentIndex < ast.length && \n        ast[parentIndex]._depth >= ast[0]._depth)\n          parentIndex++;\n\n      // Found its parent.\n      if (parentIndex < ast.length) {\n        child = ast[0];\n        parent = ast[parentIndex];\n        (parent.children || (parent.children = [])).push(child);\n        ast.shift();\n      // They're siblings.\n      } else {\n        return ast;\n      }\n    }\n    return ast;\n  }\n}"]}