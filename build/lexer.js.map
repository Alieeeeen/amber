{"version":3,"sources":["../src/lexer.js"],"names":["spaceStriper","openTagRe","closeTagRe","selfCloseRe","attrsRe","nestedScriptRe","type","OPENNING","CLOSING","SELFCLOSING","TEXT","Scanner","constructor","src","option","replace","Error","resetSource","getToken","lookahead","length","token","tokenStr","match","attrs","dAttrs","substring","forEach","attr","split","key","value","dValue","tagName","_type","text","dText"],"mappings":"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","file":"lexer.js","sourcesContent":["const spaceStriper = /^(\\s*)|(\\s*)$/g,\n      // No underscore is allowed.\n      openTagRe    = /^<\\s*([a-zA-Z0-9]*)((\\s+[^\\s]*=[^\\s]*)*)\\s*>$/,\n      closeTagRe   = /^<\\/\\s*([a-zA-Z0-9]*)\\s*>$/,\n      selfCloseRe  = /^<\\s*([a-zA-Z0-9]*)((\\s+[^\\s]*=[^\\s]*)*)\\s*(\\/)>$/,\n      attrsRe      = /\\s*([^\\s]+)\\s*=\\s*([^\\s]+)/g,\n      nestedScriptRe = /{(.*)}/;\n\nexport const type = {\n  OPENNING: 0,\n  CLOSING: 1,\n  SELFCLOSING: 2,\n  TEXT: 3\n};\n\nconst { OPENNING, CLOSING, SELFCLOSING, TEXT } = type;\n\nexport class Scanner {\n  constructor(src, option) {\n    this.src = src || '';\n\n    // Trim head & tail space.\n    this.src = this.src.replace(spaceStriper, '');\n    if (this.src !== '' && this.src[0] !== '<')\n      throw new Error(`Unexpected token: ${this.src[0]}`);\n  }\n\n  resetSource(src) {\n    if (!src) return;\n    this.src = src;\n  }\n\n  getToken() {\n    let\n      lookahead = 0,\n      length    = this.src.length, \n      src       = this.src,\n      token     = {},     // token object to return.\n      tokenStr  = '',     // string of the current token.\n      match     = null,\n      attrs     = void 0,   // static attributes for current token.\n      dAttrs    = void 0;   // dynamic attributes for current token.\n\n    // Finished.\n    if (length === 0)\n      return null;\n\n    // Tag\n    if (src[0] === '<') {\n      // Scan until it meets '>'\n      while(lookahead < length && src[lookahead] !== '>')\n        lookahead++;\n\n      // Found a tag\n      if (lookahead > 0 && src[lookahead] === '>') {\n        tokenStr = src.substring(0, lookahead + 1);\n        this.src = src.substring(lookahead + 1).replace(spaceStriper, '');\n\n        // Is it an open tag or self-closing tag?\n        if ((match = tokenStr.match(openTagRe)) || (match = tokenStr.match(selfCloseRe))) {\n          \n          // Is there attributes?\n          if (match[2]) {\n            match[2].match(attrsRe).forEach(attr => {\n              attr       = attr.split('=');\n              let key    = attr[0].replace(spaceStriper, '');\n              let value  = attr[1].replace(spaceStriper, '');\n              let dValue = null;\n\n              if ((dValue = value.match(nestedScriptRe))) {\n                // strip space.\n                dValue = dValue[1].replace(spaceStriper, '');\n                dAttrs || (dAttrs = {});\n                dAttrs[key] = dValue;\n              } else {\n                attrs = attrs || {};\n                attrs[key] = value;\n              }\n            });\n          }\n\n          token.tagName = match[1];\n          token.attrs   = attrs;\n          token.dAttrs  = dAttrs;\n          token._type    = match[match.length - 1] === '/' ? SELFCLOSING : OPENNING;\n          // Is it a close tag?\n        } else if ((match = tokenStr.match(closeTagRe))) {\n          token.tagName = match[1];\n          token._type    = CLOSING;\n        } else {\n          throw new Error(`Unexpected token: ${tokenStr}`);\n        }\n      } else {\n        throw new Error(`Missing '>'`);\n      }\n      // Text.\n    } else {\n      // Determine what type of text.\n      while(lookahead < length && src[lookahead] !== '<' && src[lookahead] !== '{')\n        lookahead++;\n\n      // static text.\n      if (lookahead > 0) {\n        token._type = TEXT;\n        token.text = src.substring(0, lookahead).replace(spaceStriper, '');\n      // dynamic text\n      } else if (src[lookahead] === '{') {\n        while(lookahead < length &&\n            src[lookahead] !== '}' &&\n            src[lookahead] !== '<')\n          lookahead++;\n\n        if (src[lookahead] === '<') {\n          throw new Error(`Unexpected token: <`);\n\n        } else if (src[lookahead] === '}') {\n          token._type = TEXT;\n          token.dText = src.substring(1, lookahead);\n          lookahead++;  // ignore '}'\n        }\n      }\n      this.src = src.substring(lookahead);\n    }\n\n    return token;\n  }\n}"]}