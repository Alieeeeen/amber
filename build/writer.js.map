{"version":3,"sources":["../src/writer.js"],"names":["XMLStart","XMLEnd","tailingComma","customTag","JS","XML","TEXT","Writer","constructor","code","parts","parser","write","_splitXML","self","res","forEach","part","value","_emitH","vTree","result","attrs","dAttrs","tagName","children","tagNameLiteral","attrsLiteral","Error","match","_emitAttrs","replace","length","child","_type","_emitText","attrsObj","literal","keys","Object","i","textObj","text","dText","src","startIndex","endIndex","push","type","index","toVTree","substring"],"mappings":"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","file":"writer.js","sourcesContent":["import { Parser } from './parser';\nimport { type } from './lexer';\n\nconst XMLStart = /\\(\\s*</, XMLEnd = />\\s*\\)/;\nconst tailingComma = /,\\s*$/;\nconst customTag = /^[A-Z]/;\n\nexport const JS = 0, XML = 1;\nconst { TEXT } = type;\n\n\nexport class Writer {\n  constructor(code) {\n    this.code = code || '';\n    this.parts = [];\n    this.parser = new Parser();\n  }\n\n  write() {\n    this._splitXML();\n    const self = this;\n    const parts = this.parts;\n    let   res = '';\n    parts.forEach(part => {\n      res += part.value;\n    });\n\n    //console.log(res);\n    return res;\n  }\n\n  _emitH(vTree) {\n    if (!vTree) return null;\n    // final result.\n    let result = 'h(\\n\\t';\n\n    // for shorter reference and faster access.\n    let\n      attrs     = vTree.attrs,\n      dAttrs    = vTree.dAttrs,\n      tagName   = vTree.tagName,\n      children  = vTree.children;\n\n    let\n      tagNameLiteral = '',\n      attrsLiteral   = '';\n\n    let self = this;\n\n    if (!vTree.tagName) {\n      throw new Error('Unrecognizable shit');\n    }\n\n    tagNameLiteral = tagName.match(customTag) ? `${tagName}, ` : `\"${tagName}\", `;\n    attrsLiteral   = this._emitAttrs(attrs);\n    attrsLiteral  += this._emitAttrs(dAttrs);\n    // strip tailing comma.\n    attrsLiteral = attrsLiteral.replace(tailingComma, '');\n    attrsLiteral = attrsLiteral !== '' ? `{ ${attrsLiteral} }` : '';\n\n    result += `${tagNameLiteral}`;\n    result += attrsLiteral.length ? attrsLiteral : 'null';\n\n    if (children) {\n      children.forEach(child => {\n        if (child.tagName)\n          result = `${result}, ${self._emitH(child)}`;\n        else if (child._type === TEXT) {\n          result = `${result}, ${self._emitText(child)}`;\n        }\n      });\n    }\n\n    result += ')';\n    return result;\n  }\n\n  _emitAttrs(attrsObj) {\n    let literal = '';\n    \n    const keys = Object.keys(attrsObj || {});\n    if (keys.length) {\n      for (let i = 0; i < keys.length; i++) {\n        literal += `${keys[i]}: ${attrsObj[keys[i]]}, `;\n      }\n    }\n\n    return literal;\n  }\n\n  _emitText(textObj) {\n    if (!textObj) return '';\n    let literal = '';\n\n    const text  = textObj.text || '';\n    const dText = textObj.dText || '';\n    literal += text.length ? `\"${text}\"` : `${dText}`;\n    return literal;\n  }\n\n  /** \n   * Split code into different parts. \n  */\n  _splitXML(src) {\n    let \n      startIndex = 0,\n      endIndex   = 0,\n      vTree      = void 0,\n      parser     = this.parser,\n      code       = src || this.code,\n      parts      = this.parts,\n      match      = (code || '').match(XMLStart);\n\n    if (code.length === 0)  return false;\n    this.code = code;\n\n    // No XML is found.\n    if (!match) {\n      this.parts.push({\n        type: JS,\n        value: code\n      });\n      return parts;\n    }\n\n    while(code.length && match) {\n      startIndex = match.index;\n      match = code.match(XMLEnd);\n\n      if (!match)\n        throw new Error(`Missing end: ${code[startIndex]}`);\n\n      endIndex = match.index;\n      vTree = parser.toVTree(code.substring(startIndex + 1, endIndex + 1));\n\n      parts.push({\n        type: JS,\n        value: code.substring(0, startIndex)\n      });\n\n      parts.push({\n        type: XML,\n        value: this._emitH(vTree[0])\n      });\n\n      code = code.substring(endIndex + match[0].length);\n      match = code.match(XMLStart);\n    }\n\n    if (code.length) {\n      parts.push({\n        type: JS,\n        value: code\n      });\n    }\n    return parts;\n  }\n}"]}